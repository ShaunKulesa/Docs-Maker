<h1 id="name">NAME</h1>
<p>http - Client-side implementation of the HTTP/1.1 protocol</p>
<h1 id="synopsis">SYNOPSIS</h1>
<p><strong>package require http ?2.9?</strong></p>
<p><strong>::http::config ?</strong><em>-option value</em> ...?</p>
<p><strong>::http::geturl</strong> <em>url</em> ?<em>-option value</em>
...?</p>
<p><strong>::http::formatQuery</strong> <em>key value</em> ?<em>key
value</em> ...?</p>
<p><strong>::http::quoteString</strong> <em>value</em></p>
<p><strong>::http::reset</strong> <em>token</em> ?<em>why</em>?</p>
<p><strong>::http::wait</strong> <em>token</em></p>
<p><strong>::http::status</strong> <em>token</em></p>
<p><strong>::http::size</strong> <em>token</em></p>
<p><strong>::http::code</strong> <em>token</em></p>
<p><strong>::http::ncode</strong> <em>token</em></p>
<p><strong>::http::meta</strong> <em>token</em></p>
<p><strong>::http::data</strong> <em>token</em></p>
<p><strong>::http::error</strong> <em>token</em></p>
<p><strong>::http::cleanup</strong> <em>token</em></p>
<p><strong>::http::register</strong> <em>proto port command</em></p>
<p><strong>::http::registerError</strong> <em>port</em>
?<em>message</em>?</p>
<p><strong>::http::unregister</strong> <em>proto</em></p>
<h1 id="exported-commands">EXPORTED COMMANDS</h1>
<p>Namespace <strong>http</strong> exports the commands
<strong>config</strong>, <strong>formatQuery</strong>,
<strong>geturl</strong>, <strong>quoteString</strong>,
<strong>register</strong>, <strong>registerError</strong>,
<strong>reset</strong>, <strong>unregister</strong>, and
<strong>wait</strong>.</p>
<p>It does not export the commands <strong>cleanup</strong>,
<strong>code</strong>, <strong>data</strong>, <strong>error</strong>,
<strong>meta</strong>, <strong>ncode</strong>, <strong>size</strong>, or
<strong>status</strong>.</p>
<h1 id="description">DESCRIPTION</h1>
<p>The <strong>http</strong> package provides the client side of the
HTTP/1.1 protocol, as defined in RFC 7230 to RFC 7235, which supersede
RFC 2616. The package implements the GET, POST, and HEAD operations of
HTTP/1.1. It allows configuration of a proxy host to get through
firewalls. The package is compatible with the <strong>Safesock</strong>
security policy, so it can be used by untrusted applets to do URL
fetching from a restricted set of hosts. This package can be extended to
support additional HTTP transport protocols, such as HTTPS, by providing
a custom <strong>socket</strong> command, via
<strong>::http::register</strong>.</p>
<p>The <strong>::http::geturl</strong> procedure does a HTTP
transaction. Its <em>options</em> determine whether a GET, POST, or HEAD
transaction is performed. The return value of
<strong>::http::geturl</strong> is a token for the transaction. The
value is also the name of an array in the ::http namespace that contains
state information about the transaction. The elements of this array are
described in the <strong>STATE ARRAY</strong> section.</p>
<p>If the <strong>-command</strong> option is specified, then the HTTP
operation is done in the background. <strong>::http::geturl</strong>
returns immediately after generating the HTTP request and the callback
is invoked when the transaction completes. For this to work, the Tcl
event loop must be active. In Tk applications this is always true. For
pure-Tcl applications, the caller can use <strong>::http::wait</strong>
after calling <strong>::http::geturl</strong> to start the event
loop.</p>
<p><strong>Note:</strong> The event queue is even used without the
<strong>-command</strong> option. As a side effect, arbitrary commands
may be processed while <strong>http::geturl</strong> is running.</p>
<h1 id="commands">COMMANDS</h1>
<dl>
<dt><strong>::http::config</strong> ?<em>options</em>?</dt>
<dd>
<p>The <strong>::http::config</strong> command is used to set and query
the name of the proxy server and port, and the User-Agent name used in
the HTTP requests. If no options are specified, then the current
configuration is returned. If a single argument is specified, then it
should be one of the flags described below. In this case the current
value of that setting is returned. Otherwise, the options should be a
set of flags and values that define the configuration:</p>
<dl>
<dt><strong>-accept</strong> <em>mimetypes</em></dt>
<dd>
<p>The Accept header of the request. The default is */*, which means
that all types of documents are accepted. Otherwise you can supply a
comma-separated list of mime type patterns that you are willing to
receive. For example,</p>
</dd>
<dt><strong>-pipeline</strong> <em>boolean</em></dt>
<dd>
<p>Specifies whether HTTP/1.1 transactions on a persistent socket will
be pipelined. See the <strong>PERSISTENT SOCKETS</strong> section for
details. The default is 1.</p>
</dd>
<dt><strong>-postfresh</strong> <em>boolean</em></dt>
<dd>
<p>Specifies whether requests that use the <strong>POST</strong> method
will always use a fresh socket, overriding the
<strong>-keepalive</strong> option of command
<strong>http::geturl</strong>. See the <strong>PERSISTENT
SOCKETS</strong> section for details. The default is 0.</p>
</dd>
<dt><strong>-proxyhost</strong> <em>hostname</em></dt>
<dd>
<p>The name of the proxy host, if any. If this value is the empty
string, the URL host is contacted directly.</p>
</dd>
<dt><strong>-proxyport</strong> <em>number</em></dt>
<dd>
<p>The proxy port number.</p>
</dd>
<dt><strong>-proxyfilter</strong> <em>command</em></dt>
<dd>
<p>The command is a callback that is made during
<strong>::http::geturl</strong> to determine if a proxy is required for
a given host. One argument, a host name, is added to <em>command</em>
when it is invoked. If a proxy is required, the callback should return a
two-element list containing the proxy server and proxy port. Otherwise
the filter should return an empty list. The default filter returns the
values of the <strong>-proxyhost</strong> and
<strong>-proxyport</strong> settings if they are non-empty.</p>
<p>The <strong>::http::geturl</strong> command runs the
<strong>-proxyfilter</strong> callback inside a <strong>catch</strong>
command. Therefore an error in the callback command does not call the
<strong>bgerror</strong> handler. See the <strong>ERRORS</strong>
section for details.</p>
</dd>
<dt><strong>-repost</strong> <em>boolean</em></dt>
<dd>
<p>Specifies what to do if a POST request over a persistent connection
fails because the server has half-closed the connection. If boolean
<strong>true</strong>, the request will be automatically retried; if
boolean <strong>false</strong> it will not, and the application that
uses <strong>http::geturl</strong> is expected to seek user confirmation
before retrying the POST. The value <strong>true</strong> should be used
only under certain conditions. See the <strong>PERSISTENT
SOCKETS</strong> section for details. The default is 0.</p>
</dd>
<dt><strong>-urlencoding</strong> <em>encoding</em></dt>
<dd>
<p>The <em>encoding</em> used for creating the x-url-encoded URLs with
<strong>::http::formatQuery</strong> and
<strong>::http::quoteString</strong>. The default is
<strong>utf-8</strong>, as specified by RFC 2718. Prior to http 2.5 this
was unspecified, and that behavior can be returned by specifying the
empty string (<strong>{}</strong>), although <em>iso8859-1</em> is
recommended to restore similar behavior but without the
<strong>::http::formatQuery</strong> or
<strong>::http::quoteString</strong> throwing an error processing
non-latin-1 characters.</p>
</dd>
<dt><strong>-useragent</strong> <em>string</em></dt>
<dd>
<p>The value of the User-Agent header in the HTTP request. In an unsafe
interpreter, the default value depends upon the operating system, and
the version numbers of <strong>http</strong> and <strong>Tcl</strong>,
and is (for example) A safe interpreter cannot determine its operating
system, and so the default in a safe interpreter is to use a Windows 10
value with the current version numbers of <strong>http</strong> and
<strong>Tcl</strong>.</p>
</dd>
<dt><strong>-zip</strong> <em>boolean</em></dt>
<dd>
<p>If the value is boolean <strong>true</strong>, then by default
requests will send a header If the value is boolean
<strong>false</strong>, then by default this header will not be sent. In
either case the default can be overridden for an individual request by
supplying a custom <strong>Accept-Encoding</strong> header in the
<strong>-headers</strong> option of <strong>http::geturl</strong>. The
default is 1.</p>
</dd>
</dl>
</dd>
<dt><strong>::http::geturl</strong> <em>url</em> ?<em>options</em>?</dt>
<dd>
<p>The <strong>::http::geturl</strong> command is the main procedure in
the package. The <strong>-query</strong> option causes a POST operation
and the <strong>-validate</strong> option causes a HEAD operation;
otherwise, a GET operation is performed. The
<strong>::http::geturl</strong> command returns a <em>token</em> value
that can be used to get information about the transaction. See the
<strong>STATE ARRAY</strong> and <strong>ERRORS</strong> section for
details. The <strong>::http::geturl</strong> command blocks until the
operation completes, unless the <strong>-command</strong> option
specifies a callback that is invoked when the HTTP transaction
completes. <strong>::http::geturl</strong> takes several options:</p>
<dl>
<dt><strong>-binary</strong> <em>boolean</em></dt>
<dd>
<p>Specifies whether to force interpreting the URL data as binary.
Normally this is auto-detected (anything not beginning with a
<strong>text</strong> content type or whose content encoding is
<strong>gzip</strong> or <strong>compress</strong> is considered binary
data).</p>
</dd>
<dt><strong>-blocksize</strong> <em>size</em></dt>
<dd>
<p>The block size used when reading the URL. At most <em>size</em> bytes
are read at once. After each block, a call to the
<strong>-progress</strong> callback is made (if that option is
specified).</p>
</dd>
<dt><strong>-channel</strong> <em>name</em></dt>
<dd>
<p>Copy the URL contents to channel <em>name</em> instead of saving it
in <strong>state(body)</strong>.</p>
</dd>
<dt><strong>-command</strong> <em>callback</em></dt>
<dd>
<p>Invoke <em>callback</em> after the HTTP transaction completes. This
option causes <strong>::http::geturl</strong> to return immediately. The
<em>callback</em> gets an additional argument that is the <em>token</em>
returned from <strong>::http::geturl</strong>. This token is the name of
an array that is described in the <strong>STATE ARRAY</strong> section.
Here is a template for the callback:</p>
<pre><code>proc httpCallback {token} {
    upvar #0 $token state
    # Access state as a Tcl array
}</code></pre>
<p>The <strong>::http::geturl</strong> command runs the
<strong>-command</strong> callback inside a <strong>catch</strong>
command. Therefore an error in the callback command does not call the
<strong>bgerror</strong> handler. See the <strong>ERRORS</strong>
section for details.</p>
</dd>
<dt><strong>-handler</strong> <em>callback</em></dt>
<dd>
<p>Invoke <em>callback</em> whenever HTTP data is available; if present,
nothing else will be done with the HTTP data. This procedure gets two
additional arguments: the socket for the HTTP data and the
<em>token</em> returned from <strong>::http::geturl</strong>. The token
is the name of a global array that is described in the <strong>STATE
ARRAY</strong> section. The procedure is expected to return the number
of bytes read from the socket. Here is a template for the callback:</p>
<pre><code>proc httpHandlerCallback {socket token} {
    upvar #0 $token state
    # Access socket, and state as a Tcl array
    # For example...
    ...
    set data [read $socket 1000]
    set nbytes [string length $data]
    ...
    return $nbytes
}</code></pre>
<p>The <strong>http::geturl</strong> code for the
<strong>-handler</strong> option is not compatible with either
compression or chunked transfer-encoding. If <strong>-handler</strong>
is specified, then to work around these issues
<strong>http::geturl</strong> will reduce the HTTP protocol to 1.0, and
override the <strong>-zip</strong> option (i.e. it will not send the
header "<strong>Accept-Encoding: gzip,deflate,compress</strong>").</p>
<p>If options <strong>-handler</strong> and <strong>-channel</strong>
are used together, the handler is responsible for copying the data from
the HTTP socket to the specified channel. The name of the channel is
available to the handler as element <strong>-channel</strong> of the
token array.</p>
<p>The <strong>::http::geturl</strong> command runs the
<strong>-handler</strong> callback inside a <strong>catch</strong>
command. Therefore an error in the callback command does not call the
<strong>bgerror</strong> handler. See the <strong>ERRORS</strong>
section for details.</p>
</dd>
<dt><strong>-headers</strong> <em>keyvaluelist</em></dt>
<dd>
<p>This option is used to add headers not already specified by
<strong>::http::config</strong> to the HTTP request. The
<em>keyvaluelist</em> argument must be a list with an even number of
elements that alternate between keys and values. The keys become header
field names. Newlines are stripped from the values so the header cannot
be corrupted. For example, if <em>keyvaluelist</em> is <strong>Pragma
no-cache</strong> then the following header is included in the HTTP
request:</p>
<pre><code>Pragma: no-cache</code></pre>
</dd>
<dt><strong>-keepalive</strong> <em>boolean</em></dt>
<dd>
<p>If boolean <strong>true</strong>, attempt to keep the connection open
for servicing multiple requests. Default is 0.</p>
</dd>
<dt><strong>-method</strong> <em>type</em></dt>
<dd>
<p>Force the HTTP request method to <em>type</em>.
<strong>::http::geturl</strong> will auto-select GET, POST or HEAD based
on other options, but this option overrides that selection and enables
choices like PUT and DELETE for WebDAV support.</p>
<p>It is the caller's responsibility to ensure that the headers and
request body (if any) conform to the requirements of the request method.
For example, if using <strong>-method</strong> <em>POST</em> to send a
POST with an empty request body, the caller must also supply the
option</p>
</dd>
<dt><strong>-myaddr</strong> <em>address</em></dt>
<dd>
<p>Pass an specific local address to the underlying
<strong>socket</strong> call in case multiple interfaces are
available.</p>
</dd>
<dt><strong>-progress</strong> <em>callback</em></dt>
<dd>
<p>The <em>callback</em> is made after each transfer of data from the
URL. The callback gets three additional arguments: the <em>token</em>
from <strong>::http::geturl</strong>, the expected total size of the
contents from the <strong>Content-Length</strong> meta-data, and the
current number of bytes transferred so far. The expected total size may
be unknown, in which case zero is passed to the callback. Here is a
template for the progress callback:</p>
<pre><code>proc httpProgress {token total current} {
    upvar #0 $token state
}</code></pre>
</dd>
<dt><strong>-protocol</strong> <em>version</em></dt>
<dd>
<p>Select the HTTP protocol version to use. This should be 1.0 or 1.1
(the default). Should only be necessary for servers that do not
understand or otherwise complain about HTTP/1.1.</p>
</dd>
<dt><strong>-query</strong> <em>query</em></dt>
<dd>
<p>This flag (if the value is non-empty) causes
<strong>::http::geturl</strong> to do a POST request that passes the
string <em>query</em> verbatim to the server as the request payload. The
content format (and encoding) of <em>query</em> is announced by the
request header <strong>Content-Type</strong> which is set by the option
<strong>-type</strong>. Any value of <strong>-type</strong> is
permitted, and it is the responsibility of the caller to supply
<em>query</em> in the correct format.</p>
<p>If <strong>-type</strong> is not specified, it defaults to
<em>application/x-www-form-urlencoded</em>, which requires
<em>query</em> to be an x-url-encoding formatted query-string (this
<strong>-type</strong> and query format are used in a POST submitted
from an html form). The <strong>::http::formatQuery</strong> procedure
can be used to do the formatting.</p>
</dd>
<dt><strong>-queryblocksize</strong> <em>size</em></dt>
<dd>
<p>The block size used when posting query data to the URL. At most
<em>size</em> bytes are written at once. After each block, a call to the
<strong>-queryprogress</strong> callback is made (if that option is
specified).</p>
</dd>
<dt><strong>-querychannel</strong> <em>channelID</em></dt>
<dd>
<p>This flag causes <strong>::http::geturl</strong> to do a POST request
that passes the data contained in <em>channelID</em> to the server. The
data contained in <em>channelID</em> must be an x-url-encoding formatted
query unless the <strong>-type</strong> option below is used. If a
Content-Length header is not specified via the <strong>-headers</strong>
options, <strong>::http::geturl</strong> attempts to determine the size
of the post data in order to create that header. If it is unable to
determine the size, it returns an error.</p>
</dd>
<dt><strong>-queryprogress</strong> <em>callback</em></dt>
<dd>
<p>The <em>callback</em> is made after each transfer of data to the URL
(i.e. POST) and acts exactly like the <strong>-progress</strong> option
(the callback format is the same).</p>
</dd>
<dt><strong>-strict</strong> <em>boolean</em></dt>
<dd>
<p>Whether to enforce RFC 3986 URL validation on the request. Default is
1.</p>
</dd>
<dt><strong>-timeout</strong> <em>milliseconds</em></dt>
<dd>
<p>If <em>milliseconds</em> is non-zero, then
<strong>::http::geturl</strong> sets up a timeout to occur after the
specified number of milliseconds. A timeout results in a call to
<strong>::http::reset</strong> and to the <strong>-command</strong>
callback, if specified. The return value of
<strong>::http::status</strong> is <strong>timeout</strong> after a
timeout has occurred.</p>
</dd>
<dt><strong>-type</strong> <em>mime-type</em></dt>
<dd>
<p>Use <em>mime-type</em> as the <strong>Content-Type</strong> value,
instead of the default value
(<strong>application/x-www-form-urlencoded</strong>) during a POST
operation.</p>
</dd>
<dt><strong>-validate</strong> <em>boolean</em></dt>
<dd>
<p>If <em>boolean</em> is non-zero, then <strong>::http::geturl</strong>
does an HTTP HEAD request. This request returns meta information about
the URL, but the contents are not returned. The meta information is
available in the <strong>state(meta)</strong> variable after the
transaction. See the <strong>STATE ARRAY</strong> section for
details.</p>
</dd>
</dl>
</dd>
<dt><strong>::http::formatQuery</strong> <em>key value</em> ?<em>key
value</em> ...?</dt>
<dd>
<p>This procedure does x-url-encoding of query data. It takes an even
number of arguments that are the keys and values of the query. It
encodes the keys and values, and generates one string that has the
proper &amp; and = separators. The result is suitable for the
<strong>-query</strong> value passed to
<strong>::http::geturl</strong>.</p>
</dd>
<dt><strong>::http::quoteString</strong> <em>value</em></dt>
<dd>
<p>This procedure does x-url-encoding of string. It takes a single
argument and encodes it.</p>
</dd>
<dt><strong>::http::reset</strong> <em>token</em> ?<em>why</em>?</dt>
<dd>
<p>This command resets the HTTP transaction identified by
<em>token</em>, if any. This sets the <strong>state(status)</strong>
value to <em>why</em>, which defaults to <strong>reset</strong>, and
then calls the registered <strong>-command</strong> callback.</p>
</dd>
<dt><strong>::http::wait</strong> <em>token</em></dt>
<dd>
<p>This is a convenience procedure that blocks and waits for the
transaction to complete. This only works in trusted code because it uses
<strong>vwait</strong>. Also, it is not useful for the case where
<strong>::http::geturl</strong> is called <em>without</em> the
<strong>-command</strong> option because in this case the
<strong>::http::geturl</strong> call does not return until the HTTP
transaction is complete, and thus there is nothing to wait for.</p>
</dd>
<dt><strong>::http::data</strong> <em>token</em></dt>
<dd>
<p>This is a convenience procedure that returns the
<strong>body</strong> element (i.e., the URL data) of the state
array.</p>
</dd>
<dt><strong>::http::error</strong> <em>token</em></dt>
<dd>
<p>This is a convenience procedure that returns the
<strong>error</strong> element of the state array.</p>
</dd>
<dt><strong>::http::status</strong> <em>token</em></dt>
<dd>
<p>This is a convenience procedure that returns the
<strong>status</strong> element of the state array.</p>
</dd>
<dt><strong>::http::code</strong> <em>token</em></dt>
<dd>
<p>This is a convenience procedure that returns the
<strong>http</strong> element of the state array.</p>
</dd>
<dt><strong>::http::ncode</strong> <em>token</em></dt>
<dd>
<p>This is a convenience procedure that returns just the numeric return
code (200, 404, etc.) from the <strong>http</strong> element of the
state array.</p>
</dd>
<dt><strong>::http::size</strong> <em>token</em></dt>
<dd>
<p>This is a convenience procedure that returns the
<strong>currentsize</strong> element of the state array, which
represents the number of bytes received from the URL in the
<strong>::http::geturl</strong> call.</p>
</dd>
<dt><strong>::http::meta</strong> <em>token</em></dt>
<dd>
<p>This is a convenience procedure that returns the
<strong>meta</strong> element of the state array which contains the HTTP
response headers. See below for an explanation of this element.</p>
</dd>
<dt><strong>::http::cleanup</strong> <em>token</em></dt>
<dd>
<p>This procedure cleans up the state associated with the connection
identified by <em>token</em>. After this call, the procedures like
<strong>::http::data</strong> cannot be used to get information about
the operation. It is <em>strongly</em> recommended that you call this
function after you are done with a given HTTP request. Not doing so will
result in memory not being freed, and if your app calls
<strong>::http::geturl</strong> enough times, the memory leak could
cause a performance hit...or worse.</p>
</dd>
<dt><strong>::http::register</strong> <em>proto port command</em></dt>
<dd>
<p>This procedure allows one to provide custom HTTP transport types such
as HTTPS, by registering a prefix, the default port, and the command to
execute to create the Tcl <strong>channel</strong>. E.g.:</p>
<pre><code>package require http
package require tls

::http::register https 443 ::tls::socket

set token [::http::geturl https://my.secure.site/]</code></pre>
</dd>
<dt><strong>::http::registerError</strong> <em>port</em>
?<em>message</em>?</dt>
<dd>
<p>This procedure allows a registered protocol handler to deliver an
error message for use by <strong>http</strong>. Calling this command
does not raise an error. The command is useful when a registered
protocol detects an problem (for example, an invalid TLS certificate)
that will cause an error to propagate to <strong>http</strong>. The
command allows <strong>http</strong> to provide a precise error message
rather than a general one. The command returns the value provided by the
last call with argument <em>message</em>, or the empty string if no such
call has been made.</p>
</dd>
<dt><strong>::http::unregister</strong> <em>proto</em></dt>
<dd>
<p>This procedure unregisters a protocol handler that was previously
registered via <strong>::http::register</strong>, returning a two-item
list of the default port and handler command that was previously
installed (via <strong>::http::register</strong>) if there was such a
handler, and an error if there was no such handler.</p>
</dd>
</dl>
<h1 id="errors">ERRORS</h1>
<p>The <strong>::http::geturl</strong> procedure will raise errors in
the following cases: invalid command line options, an invalid URL, a URL
on a non-existent host, or a URL at a bad port on an existing host.
These errors mean that it cannot even start the network transaction. It
will also raise an error if it gets an I/O error while writing out the
HTTP request header. For synchronous <strong>::http::geturl</strong>
calls (where <strong>-command</strong> is not specified), it will raise
an error if it gets an I/O error while reading the HTTP reply headers or
data. Because <strong>::http::geturl</strong> does not return a token in
these cases, it does all the required cleanup and there is no issue of
your app having to call <strong>::http::cleanup</strong>.</p>
<p>For asynchronous <strong>::http::geturl</strong> calls, all of the
above error situations apply, except that if there is any error while
reading the HTTP reply headers or data, no exception is thrown. This is
because after writing the HTTP headers, <strong>::http::geturl</strong>
returns, and the rest of the HTTP transaction occurs in the background.
The command callback can check if any error occurred during the read by
calling <strong>::http::status</strong> to check the status and if its
<em>error</em>, calling <strong>::http::error</strong> to get the error
message.</p>
<p>Alternatively, if the main program flow reaches a point where it
needs to know the result of the asynchronous HTTP request, it can call
<strong>::http::wait</strong> and then check status and error, just as
the callback does.</p>
<p>The <strong>::http::geturl</strong> command runs the
<strong>-command</strong>, <strong>-handler</strong>, and
<strong>-proxyfilter</strong> callbacks inside a <strong>catch</strong>
command. Therefore an error in the callback command does not call the
<strong>bgerror</strong> handler. When debugging one of these callbacks,
it may be convenient to report errors by using a <strong>catch</strong>
command within the callback command itself, e.g. to write an error
message to stdout.</p>
<p>In any case, you must still call <strong>::http::cleanup</strong> to
delete the state array when you are done.</p>
<p>There are other possible results of the HTTP transaction determined
by examining the status from <strong>::http::status</strong>. These are
described below.</p>
<dl>
<dt><strong>ok</strong></dt>
<dd>
<p>If the HTTP transaction completes entirely, then status will be
<strong>ok</strong>. However, you should still check the
<strong>::http::code</strong> value to get the HTTP status. The
<strong>::http::ncode</strong> procedure provides just the numeric error
(e.g., 200, 404 or 500) while the <strong>::http::code</strong>
procedure returns a value like</p>
</dd>
<dt><strong>eof</strong></dt>
<dd>
<p>If the server closes the socket without replying, then no error is
raised, but the status of the transaction will be
<strong>eof</strong>.</p>
</dd>
<dt><strong>error</strong></dt>
<dd>
<p>The error message will also be stored in the <strong>error</strong>
status array element, accessible via <strong>::http::error</strong>.</p>
</dd>
<dt><strong>timeout</strong></dt>
<dd>
<p>A timeout occurred before the transaction could complete</p>
</dd>
<dt><strong>reset</strong></dt>
<dd>
<p>user-reset</p>
</dd>
</dl>
<p>Another error possibility is that <strong>::http::geturl</strong> is
unable to write all the post query data to the server before the server
responds and closes the socket. The error message is saved in the
<strong>posterror</strong> status array element and then
<strong>::http::geturl</strong> attempts to complete the transaction. If
it can read the server's response it will end up with an
<strong>ok</strong> status, otherwise it will have an
<strong>eof</strong> status.</p>
<h1 id="state-array">STATE ARRAY</h1>
<p>The <strong>::http::geturl</strong> procedure returns a
<em>token</em> that can be used to get to the state of the HTTP
transaction in the form of a Tcl array. Use this construct to create an
easy-to-use array variable:</p>
<pre><code>upvar #0 $token state</code></pre>
<p>Once the data associated with the URL is no longer needed, the state
array should be unset to free up storage. The
<strong>::http::cleanup</strong> procedure is provided for that purpose.
The following elements of the array are supported:</p>
<blockquote>
<dl>
<dt><strong>binary</strong></dt>
<dd>
<p>This is boolean <strong>true</strong> if (after decoding any
compression specified by the response header) the HTTP response is
binary. It is boolean <strong>false</strong> if the HTTP response is
text.</p>
</dd>
<dt><strong>body</strong></dt>
<dd>
<p>The contents of the URL. This will be empty if the
<strong>-channel</strong> option has been specified. This value is
returned by the <strong>::http::data</strong> command.</p>
</dd>
<dt><strong>charset</strong></dt>
<dd>
<p>The value of the charset attribute from the
<strong>Content-Type</strong> meta-data value. If none was specified,
this defaults to the RFC standard <strong>iso8859-1</strong>, or the
value of <strong>$::http::defaultCharset</strong>. Incoming text data
will be automatically converted from this charset to utf-8.</p>
</dd>
<dt><strong>coding</strong></dt>
<dd>
<p>A copy of the <strong>Content-Encoding</strong> meta-data value.</p>
</dd>
<dt><strong>currentsize</strong></dt>
<dd>
<p>The current number of bytes fetched from the URL. This value is
returned by the <strong>::http::size</strong> command.</p>
</dd>
<dt><strong>error</strong></dt>
<dd>
<p>If defined, this is the error string seen when the HTTP transaction
was aborted.</p>
</dd>
<dt><strong>http</strong></dt>
<dd>
<p>The HTTP status reply from the server. This value is returned by the
<strong>::http::code</strong> command. The format of this value is:</p>
<pre><code>HTTP/1.1 code string</code></pre>
<p>The <em>code</em> is a three-digit number defined in the HTTP
standard. A code of 200 is OK. Codes beginning with 4 or 5 indicate
errors. Codes beginning with 3 are redirection errors. In this case the
<strong>Location</strong> meta-data specifies a new URL that contains
the requested information.</p>
</dd>
<dt><strong>meta</strong></dt>
<dd>
<p>The HTTP protocol returns meta-data that describes the URL contents.
The <strong>meta</strong> element of the state array is a list of the
keys and values of the meta-data. This is in a format useful for
initializing an array that just contains the meta-data:</p>
<pre><code>array set meta $state(meta)</code></pre>
<p>Some of the meta-data keys are listed below, but the HTTP standard
defines more, and servers are free to add their own.</p>
<dl>
<dt><strong>Content-Type</strong></dt>
<dd>
<p>The type of the URL contents. Examples include
<strong>text/html</strong>, <strong>image/gif,</strong>
<strong>application/postscript</strong> and
<strong>application/x-tcl</strong>.</p>
</dd>
<dt><strong>Content-Length</strong></dt>
<dd>
<p>The advertised size of the contents. The actual size obtained by
<strong>::http::geturl</strong> is available as
<strong>state(currentsize)</strong>.</p>
</dd>
<dt><strong>Location</strong></dt>
<dd>
<p>An alternate URL that contains the requested data.</p>
</dd>
</dl>
</dd>
<dt><strong>posterror</strong></dt>
<dd>
<p>The error, if any, that occurred while writing the post query data to
the server.</p>
</dd>
<dt><strong>status</strong></dt>
<dd>
<p>See description in the chapter <strong>ERRORS</strong> above for a
list and description of <strong>status</strong>. During the transaction
this value is the empty string.</p>
</dd>
<dt><strong>totalsize</strong></dt>
<dd>
<p>A copy of the <strong>Content-Length</strong> meta-data value.</p>
</dd>
<dt><strong>type</strong></dt>
<dd>
<p>A copy of the <strong>Content-Type</strong> meta-data value.</p>
</dd>
<dt><strong>url</strong></dt>
<dd>
<p>The requested URL.</p>
</dd>
</dl>
</blockquote>
<h1 id="persistent-connections">PERSISTENT CONNECTIONS</h1>
<h2 id="basics">BASICS</h2>
<p>See RFC 7230 Sec 6, which supersedes RFC 2616 Sec 8.1.</p>
<p>A persistent connection allows multiple HTTP/1.1 transactions to be
carried over the same TCP connection. Pipelining allows a client to make
multiple requests over a persistent connection without waiting for each
response. The server sends responses in the same order that the requests
were received.</p>
<p>If a POST request fails to complete, typically user confirmation is
needed before sending the request again. The user may wish to verify
whether the server was modified by the failed POST request, before
sending the same request again.</p>
<p>A HTTP request will use a persistent socket if the call to
<strong>http::geturl</strong> has the option <strong>-keepalive
true</strong>. It will use pipelining where permitted if the
<strong>http::config</strong> option <strong>-pipeline</strong> is
boolean <strong>true</strong> (its default value).</p>
<p>The http package maintains no more than one persistent connection to
each server (i.e. each value of If <strong>http::geturl</strong> is
called to make a request over a persistent connection while the
connection is busy with another request, the new request will be held in
a queue until the connection is free.</p>
<p>The http package does not support HTTP/1.0 persistent connections
controlled by the <strong>Keep-Alive</strong> header.</p>
<h2 id="special-cases">SPECIAL CASES</h2>
<p>This subsection discusses issues related to closure of the persistent
connection by the server, automatic retry of failed requests, the
special treatment necessary for POST requests, and the options for
dealing with these cases.</p>
<p>In accordance with RFC 7230, <strong>http::geturl</strong> does not
pipeline requests that use the POST method. If a POST uses a persistent
connection and is not the first request on that connection,
<strong>http::geturl</strong> waits until it has received the response
for the previous request; or (if <strong>http::config</strong> option
<strong>-postfresh</strong> is boolean <strong>true</strong>) it uses a
new connection for each POST.</p>
<p>If the server is processing a number of pipelined requests, and sends
a response header with one of the responses (other than the last), then
subsequent responses are unfulfilled. <strong>http::geturl</strong> will
send the unfulfilled requests again over a new connection.</p>
<p>A difficulty arises when a HTTP client sends a request over a
persistent connection that has been idle for a while. The HTTP server
may half-close an apparently idle connection while the client is sending
a request, but before the request arrives at the server: in this case
(an the request will fail. The difficulty arises because the client
cannot be certain whether the POST modified the state of the server. For
HEAD or GET requests, <strong>http::geturl</strong> opens another
connection and retransmits the failed request. However, if the request
was a POST, RFC 7230 forbids automatic retry by default, suggesting
either user confirmation, or confirmation by user-agent software that
has semantic understanding of the application. The
<strong>http::config</strong> option <strong>-repost</strong> allows for
either possibility.</p>
<p>Asynchronous close events can occur only in a short interval of time.
The <strong>http</strong> package monitors each persistent connection
for closure by the server. Upon detection, the connection is also closed
at the client end, and subsequent requests will use a fresh
connection.</p>
<p>If the <strong>http::geturl</strong> command is called with option
<strong>-keepalive true</strong>, then it will both try to use an
existing persistent connection (if one is available), and it will send
the server a request header asking to keep the connection open for
future requests.</p>
<p>The <strong>http::config</strong> options <strong>-pipeline</strong>,
<strong>-postfresh</strong>, and <strong>-repost</strong> relate to
persistent connections.</p>
<p>Option <strong>-pipeline</strong>, if boolean <strong>true</strong>,
will pipeline GET and HEAD requests made over a persistent connection.
POST requests will not be pipelined - if the POST is not the first
transaction on the connection, its request will not be sent until the
previous response has finished. GET and HEAD requests made after a POST
will not be sent until the POST response has been delivered, and will
not be sent if the POST fails.</p>
<p>Option <strong>-postfresh</strong>, if boolean <strong>true</strong>,
will override the <strong>http::geturl</strong> option
<strong>-keepalive</strong>, and always open a fresh connection for a
POST request.</p>
<p>Option <strong>-repost</strong>, if <strong>true</strong>, permits
automatic retry of a POST request that fails because it uses a
persistent connection that the server has half-closed (an Subsequent GET
and HEAD requests in a failed pipeline will also be retried. <em>The
-repost option should be used only if the application understands</em>
that the retry is appropriate - specifically, the application must know
that if the failed POST successfully modified the state of the server, a
repeat POST would have no adverse effect.</p>
<h1 id="protocol-upgrades">PROTOCOL UPGRADES</h1>
<p>The HTTP/1.1 <strong>Connection</strong> and <strong>Upgrade</strong>
client headers inform the server that the client wishes to change the
protocol used over the existing connection (RFC 7230). This mechanism
can be used to request a WebSocket (RFC 6455), a higher version of the
HTTP protocol (HTTP 2), or TLS encryption. If the server accepts the
upgrade request, its response code will be 101.</p>
<p>To request a protocol upgrade when calling
<strong>http::geturl</strong>, the <strong>-headers</strong> option must
supply appropriate values for <strong>Connection</strong> and
<strong>Upgrade</strong>, and the <strong>-command</strong> option must
supply a command that implements the requested protocol and can also
handle the server response if the server refuses the protocol upgrade.
For upgrade requests <strong>http::geturl</strong> ignores the value of
option <strong>-keepalive</strong>, and always uses the value
<strong>0</strong> so that the upgrade request is not made over a
connection that is intended for multiple HTTP requests.</p>
<p>The Tcllib library <strong>websocket</strong> implements WebSockets,
and makes the necessary calls to commands in the <strong>http</strong>
package.</p>
<p>There is currently no native Tcl client library for HTTP/2.</p>
<p>The <strong>Upgrade</strong> mechanism is not used to request TLS in
web browsers, because <strong>http</strong> and <strong>https</strong>
are served over different ports. It is used by protocols such as
Internet Printing Protocol (IPP) that are built on top of
<strong>http(s)</strong> and use the same TCP port number for both
secure and insecure traffic.</p>
<p>In browsers, opportunistic encryption is instead implemented by the
<strong>Upgrade-Insecure-Requests</strong> client header. If a secure
service is available, the server response code is a 307 redirect, and
the response header <strong>Location</strong> specifies the target URL.
The browser must call <strong>http::geturl</strong> again in order to
fetch this URL. See
https://w3c.github.io/webappsec-upgrade-insecure-requests/</p>
<h1 id="example">EXAMPLE</h1>
<p>This example creates a procedure to copy a URL to a file while
printing a progress meter, and prints the meta-data associated with the
URL.</p>
<pre><code>proc httpcopy { url file {chunk 4096} } {
    set out [open $file w]
    set token [::http::geturl $url -channel $out \
            -progress httpCopyProgress -blocksize $chunk]
    close $out

    # This ends the line started by httpCopyProgress
    puts stderr &quot;&quot;

    upvar #0 $token state
    set max 0
    foreach {name value} $state(meta) {
        if {[string length $name] &gt; $max} {
            set max [string length $name]
        }
        if {[regexp -nocase ^location$ $name]} {
            # Handle URL redirects
            puts stderr &quot;Location:$value&quot;
            return [httpcopy [string trim $value] $file $chunk]
        }
    }
    incr max
    foreach {name value} $state(meta) {
        puts [format &quot;%-*s %s&quot; $max $name: $value]
    }

    return $token
}
proc httpCopyProgress {args} {
    puts -nonewline stderr .
    flush stderr
}</code></pre>
<h1 id="see-also">SEE ALSO</h1>
<p><a href="../Tcl-Commands/safe.html">safe</a>, <a
href="../Tcl-Commands/socket.html">socket</a>, safesock(n)</p>
<h1 id="keywords">KEYWORDS</h1>
<p>internet, security policy, socket, www</p>
