<h1 id="name">NAME</h1>
<p>Tcl_GetOpenFile - Return a FILE* for a channel registered in the
given interpreter (Unix only)</p>
<h1 id="synopsis">SYNOPSIS</h1>
<pre><code>#include &lt;tcl.h&gt;

int
Tcl_GetOpenFile(interp, chanID, write, checkUsage, filePtr)</code></pre>
<h1 id="arguments">ARGUMENTS</h1>
<p>Tcl interpreter from which file handle is to be obtained.</p>
<p>String identifying channel, such as <strong>stdin</strong> or
<strong>file4</strong>.</p>
<p>Non-zero means the file will be used for writing, zero means it will
be used for reading.</p>
<p>If non-zero, then an error will be generated if the file was not
opened for the access indicated by <em>write</em>.</p>
<p>Points to word in which to store pointer to FILE structure for the
file given by <em>chanID</em>.</p>
<h1 id="description">DESCRIPTION</h1>
<p><strong>Tcl_GetOpenFile</strong> takes as argument a file identifier
of the form returned by the <strong>open</strong> command and returns at
<em>*filePtr</em> a pointer to the FILE structure for the file. The
<em>write</em> argument indicates whether the FILE pointer will be used
for reading or writing. In some cases, such as a channel that connects
to a pipeline of subprocesses, different FILE pointers will be returned
for reading and writing. <strong>Tcl_GetOpenFile</strong> normally
returns <strong>TCL_OK</strong>. If an error occurs in
<strong>Tcl_GetOpenFile</strong> (e.g.Â <em>chanID</em> did not make any
sense or <em>checkUsage</em> was set and the file was not opened for the
access specified by <em>write</em>) then <strong>TCL_ERROR</strong> is
returned and the interpreter's result will contain an error message. In
the current implementation <em>checkUsage</em> is ignored and
consistency checks are always performed.</p>
<p>Note that this interface is only supported on the Unix platform.</p>
<h1 id="keywords">KEYWORDS</h1>
<p>channel, file handle, permissions, pipeline, read, write</p>
